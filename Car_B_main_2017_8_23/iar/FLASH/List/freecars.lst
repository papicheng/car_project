###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       23/Aug/2017  10:34:55
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\app\freecars.c
#    Command line =  
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\app\freecars.c
#        -D LPLD_K60 -D USE_K60DZ10 -lCN
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\FLASH\List
#        -lB
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\FLASH\List
#        -o
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR Systems\Embedded
#        Workbench 7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\app\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\CPU\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\common\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\LPLD\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\LPLD\HW\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\FatFs\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\FatFs\option\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\USB\common\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\USB\driver\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\USB\descriptor\
#        -I
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\..\..\..\lib\USB\class\
#        -Ol -I "E:\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM4
#    List file    =  
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\FLASH\List\freecars.lst
#    Object file  =  
#        G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\iar\FLASH\Obj\freecars.o
#
###############################################################################

G:\study\car\program\lib_and_example\LPLD_OSKinetis_V3\project\Car_B_main_2017_8_23\app\freecars.c
      1          
      2          
      3          #include "common.h"
      4          #include "Freecars.h"
      5          #include "timer.h"
      6          

   \                                 In section .bss, align 4
      7          uint8 uSendBuf[UartDataNum*2]={0};
   \                     uSendBuf:
   \   00000000                      DS8 36

   \                                 In section .data, align 1
      8          uint8 FreeCarsDataNum=UartDataNum*2;//它是通道数 UartDataNum*2(因为数据是Int16型的)
   \                     FreeCarsDataNum:
   \   00000000   0x22               DC8 34

   \                                 In section .bss, align 8
      9          double UartData[9] = {0};
   \                     UartData:
   \   00000000                      DS8 72
     10          

   \                                 In section .bss, align 4
     11          SerialPortType SerialPortRx;
   \                     SerialPortRx:
   \   00000000                      DS8 108
     12          //显示Freecars上位机修改数据
     13          

   \                                 In section .bss, align 1
     14          uint8 stopflag=0;
   \                     stopflag:
   \   00000000                      DS8 1
     15          

   \                                 In section .text, align 2, keep-with-next
     16          void UartDebug(void)
     17          {
   \                     UartDebug: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     18            LPLD_UART_PutChar(UART4,1);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable4  ;; 0x400ea000
   \   00000008   0x.... 0x....      BL       LPLD_UART_PutChar
     19            
     20            if(UartData[0]!=0)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000010   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x.... 0x....      BL       __aeabi_cdcmpeq
   \   0000001C   0xD008             BEQ.N    ??UartDebug_0
     21            {
     22              Speed_PID.P=(float)UartData[0];
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \   00000022   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   00000026   0x.... 0x....      BL       __aeabi_d2f
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     23            }
     24            if(UartData[1]!=0)
   \                     ??UartDebug_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000034   0xE9D0 0x2302      LDRD     R2,R3,[R0, #+8]
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x.... 0x....      BL       __aeabi_cdcmpeq
   \   00000040   0xD008             BEQ.N    ??UartDebug_1
     25            {
     26              Speed_PID.I=(float)(UartData[1]);
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \   00000046   0xE9D2 0x0102      LDRD     R0,R1,[R2, #+8]
   \   0000004A   0x.... 0x....      BL       __aeabi_d2f
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000052   0x6048             STR      R0,[R1, #+4]
     27              
     28            }
     29            if(UartData[2]!=0)
   \                     ??UartDebug_1: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000058   0xE9D0 0x2304      LDRD     R2,R3,[R0, #+16]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x.... 0x....      BL       __aeabi_cdcmpeq
   \   00000064   0xD00B             BEQ.N    ??UartDebug_2
     30            {
     31              Speed_PID.D=(int16)(UartData[2]);
   \   00000066   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \   0000006A   0xE9D2 0x0104      LDRD     R0,R1,[R2, #+16]
   \   0000006E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000072   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000074   0x.... 0x....      BL       __aeabi_i2f
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   0000007C   0x6088             STR      R0,[R1, #+8]
     32              
     33            }
     34            if(UartData[3]!=0)
   \                     ??UartDebug_2: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000082   0xE9D0 0x2306      LDRD     R2,R3,[R0, #+24]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0x.... 0x....      BL       __aeabi_cdcmpeq
   \   0000008E   0xD008             BEQ.N    ??UartDebug_3
     35            {
     36              car_stop_flag=(uint8)(UartData[3]); 
   \   00000090   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \   00000094   0xE9D2 0x0106      LDRD     R0,R1,[R2, #+24]
   \   00000098   0x.... 0x....      BL       __aeabi_d2iz
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
     37            }
     38            
     39            if(UartData[4]!=0)
   \                     ??UartDebug_3: (+1)
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   000000A6   0xE9D0 0x2308      LDRD     R2,R3,[R0, #+32]
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x.... 0x....      BL       __aeabi_cdcmpeq
   \   000000B2   0xD009             BEQ.N    ??UartDebug_4
     40            {
     41              Turn_PID.P=(int16)UartData[0];   //高速阈值
   \   000000B4   0x....             LDR.N    R2,??DataTable4_1
   \   000000B6   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   000000BA   0x.... 0x....      BL       __aeabi_d2iz
   \   000000BE   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000C0   0x.... 0x....      BL       __aeabi_i2f
   \   000000C4   0x....             LDR.N    R1,??DataTable4_4
   \   000000C6   0x6008             STR      R0,[R1, #+0]
     42            }
     43            if(UartData[5]!=0)
   \                     ??UartDebug_4: (+1)
   \   000000C8   0x....             LDR.N    R0,??DataTable4_1
   \   000000CA   0xE9D0 0x230A      LDRD     R2,R3,[R0, #+40]
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x2100             MOVS     R1,#+0
   \   000000D2   0x.... 0x....      BL       __aeabi_cdcmpeq
   \   000000D6   0xD006             BEQ.N    ??UartDebug_5
     44            {
     45              Turn_PID.D=(UartData[5]);
   \   000000D8   0x....             LDR.N    R2,??DataTable4_1
   \   000000DA   0xE9D2 0x010A      LDRD     R0,R1,[R2, #+40]
   \   000000DE   0x.... 0x....      BL       __aeabi_d2f
   \   000000E2   0x....             LDR.N    R1,??DataTable4_4
   \   000000E4   0x6088             STR      R0,[R1, #+8]
     46            }
     47            if(UartData[6]!=0)
     48            {
     49          //   Speed_PID.P=(int)(UartData[6]);
     50            }
     51            if(UartData[7]!=0)
     52            {
     53          //    Speed_PID.I=(int16)(UartData[7]);
     54            }
     55            if(UartData[8]!=0)
     56            {
     57          //    Speed_PID.D=(int16)(UartData[8]);
     58            }
     59          }
   \                     ??UartDebug_5: (+1)
   \   000000E6   0xBD01             POP      {R0,PC}          ;; return
     60          /*
     61          命令接收函数
     62          CmdNum：0~255号命令
     63          DATA  ：0~255个命令所对应的命令字
     64          */

   \                                 In section .text, align 2, keep-with-next
     65          void UartCmd(uint8 CmdNum,uint8 Data)
     66          {
   \                     UartCmd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     67            if(CmdNum==2&&Data==102)//page up
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xD10D             BNE.N    ??UartCmd_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2966             CMP      R1,#+102
   \   0000000C   0xD10A             BNE.N    ??UartCmd_0
     68            {
     69              stopflag=!stopflag;
   \   0000000E   0x....             LDR.N    R2,??DataTable4_5
   \   00000010   0x7812             LDRB     R2,[R2, #+0]
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD103             BNE.N    ??UartCmd_1
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x....             LDR.N    R3,??DataTable4_5
   \   0000001A   0x701A             STRB     R2,[R3, #+0]
   \   0000001C   0xE002             B.N      ??UartCmd_0
   \                     ??UartCmd_1: (+1)
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x....             LDR.N    R3,??DataTable4_5
   \   00000022   0x701A             STRB     R2,[R3, #+0]
     70              
     71            }
     72            if(CmdNum==2&&Data==103)//page down
   \                     ??UartCmd_0: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD106             BNE.N    ??UartCmd_2
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x2967             CMP      R1,#+103
   \   0000002E   0xD103             BNE.N    ??UartCmd_2
     73            {
     74              
     75              LPLD_UART_PutChar(UART4,'d');
   \   00000030   0x2164             MOVS     R1,#+100
   \   00000032   0x....             LDR.N    R0,??DataTable4  ;; 0x400ea000
   \   00000034   0x.... 0x....      BL       LPLD_UART_PutChar
     76            }
     77          }
   \                     ??UartCmd_2: (+1)
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
     78          /*轮询法发送一帧数据
     79          消耗时间与数据长度有关
     80          不可以放在中断里面周期性调用
     81          消耗时间计算看帮助文档
     82          */

   \                                 In section .text, align 2, keep-with-next
     83          void sendDataToScope(void)
     84          {
   \                     sendDataToScope: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     85            uint8 i,sum=0;
   \   00000002   0x2500             MOVS     R5,#+0
     86            //使用轮询的方式发送数据，当数据未发送，程序停在此处直到发送完成
     87            LPLD_UART_PutChar(UART4,251); 
   \   00000004   0xF07F 0x0104      MVNS     R1,#+4
   \   00000008   0x....             LDR.N    R0,??DataTable4  ;; 0x400ea000
   \   0000000A   0x.... 0x....      BL       LPLD_UART_PutChar
     88            LPLD_UART_PutChar(UART4,109); 
   \   0000000E   0x216D             MOVS     R1,#+109
   \   00000010   0x....             LDR.N    R0,??DataTable4  ;; 0x400ea000
   \   00000012   0x.... 0x....      BL       LPLD_UART_PutChar
     89            LPLD_UART_PutChar(UART4,37); 
   \   00000016   0x2125             MOVS     R1,#+37
   \   00000018   0x....             LDR.N    R0,??DataTable4  ;; 0x400ea000
   \   0000001A   0x.... 0x....      BL       LPLD_UART_PutChar
     90            sum+=(251); //全部数据加入校验
   \   0000001E   0x1F6D             SUBS     R5,R5,#+5
     91            sum+=(109);
   \   00000020   0x356D             ADDS     R5,R5,#+109
     92            sum+=(37);
   \   00000022   0x3525             ADDS     R5,R5,#+37
     93            for(i=0;i<FreeCarsDataNum;i++)
   \   00000024   0x2400             MOVS     R4,#+0
   \   00000026   0xE00C             B.N      ??sendDataToScope_0
     94            {
     95              LPLD_UART_PutChar(UART4,uSendBuf[i]);
   \                     ??sendDataToScope_1: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable4_6
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x5620             LDRSB    R0,[R4, R0]
   \   0000002E   0x0001             MOVS     R1,R0
   \   00000030   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000032   0x....             LDR.N    R0,??DataTable4  ;; 0x400ea000
   \   00000034   0x.... 0x....      BL       LPLD_UART_PutChar
     96              sum+=uSendBuf[i]; //全部数据加入校验
   \   00000038   0x....             LDR.N    R0,??DataTable4_6
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x5C20             LDRB     R0,[R4, R0]
   \   0000003E   0x1945             ADDS     R5,R0,R5
     97            }
   \   00000040   0x1C64             ADDS     R4,R4,#+1
   \                     ??sendDataToScope_0: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable4_7
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD3ED             BCC.N    ??sendDataToScope_1
     98            LPLD_UART_PutChar(UART4,sum);
   \   0000004C   0x0029             MOVS     R1,R5
   \   0000004E   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000050   0x....             LDR.N    R0,??DataTable4  ;; 0x400ea000
   \   00000052   0x.... 0x....      BL       LPLD_UART_PutChar
     99          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    100          /*
    101          向示波器某个通道缓冲区填充数据
    102          chanel：通道
    103          data ：数据-32768~32767
    104          push 是用来将数据填充到缓冲区里面，显然date是16位的，因此用两个8位数来储存。
    105          */

   \                                 In section .text, align 2, keep-with-next
    106          void push(uint8 chanel,uint16 data)
    107          {
    108            uSendBuf[chanel*2]=data/256;
   \                     `push`: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0xF44F 0x7280      MOV      R2,#+256
   \   00000006   0xFB91 0xF2F2      SDIV     R2,R1,R2
   \   0000000A   0x....             LDR.N    R3,??DataTable4_6
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xF803 0x2010      STRB     R2,[R3, R0, LSL #+1]
    109            uSendBuf[chanel*2+1]=data%256;
   \   00000012   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   0xF44F 0x7280      MOV      R2,#+256
   \   00000018   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   0000001C   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   00000020   0x....             LDR.N    R1,??DataTable4_6
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000028   0x7043             STRB     R3,[R0, #+1]
    110          }
   \   0000002A   0x4770             BX       LR               ;; return
    111          //接收中断回调函数

   \                                 In section .text, align 2, keep-with-next
    112          void uart4_isr(void)  //中断处理函数
    113          {
   \                     uart4_isr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    114            int i,b,d1;
    115            uint32 d;
    116            //进入接收中断函数
    117            if((UART4->S1 & UART_S1_RDRF_MASK) && (UART4->C2 & UART_C2_RIE_MASK))
   \   00000002   0x....             LDR.N    R0,??DataTable4_8  ;; 0x400ea004
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0680             LSLS     R0,R0,#+26
   \   00000008   0xF140 0x8103      BPL.W    ??uart4_isr_0
   \   0000000C   0x....             LDR.N    R0,??DataTable4_9  ;; 0x400ea003
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xF140 0x80FE      BPL.W    ??uart4_isr_0
    118            {
    119              SerialPortRx.Data = LPLD_UART_GetChar(UART4);  
   \   00000016   0x....             LDR.N    R0,??DataTable4  ;; 0x400ea000
   \   00000018   0x.... 0x....      BL       LPLD_UART_GetChar
   \   0000001C   0x....             LDR.N    R1,??DataTable4_10
   \   0000001E   0x7108             STRB     R0,[R1, #+4]
    120              if(SerialPortRx.Stack < UartRxBufferLen)
   \   00000020   0x....             LDR.N    R0,??DataTable4_10
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2864             CMP      R0,#+100
   \   00000026   0xF280 0x80F1      BGE.W    ??uart4_isr_1
    121              {
    122                SerialPortRx.Buffer[SerialPortRx.Stack++] = SerialPortRx.Data;
   \   0000002A   0x....             LDR.N    R0,??DataTable4_10
   \   0000002C   0x7900             LDRB     R0,[R0, #+4]
   \   0000002E   0x....             LDR.N    R1,??DataTable4_10
   \   00000030   0x....             LDR.N    R2,??DataTable4_10
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0x1851             ADDS     R1,R2,R1
   \   00000036   0x7188             STRB     R0,[R1, #+6]
   \   00000038   0x....             LDR.N    R0,??DataTable4_10
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable4_10
   \   00000040   0x6008             STR      R0,[R1, #+0]
    123                if(SerialPortRx.Stack >= UartRxDataLen//UartRxDataLen个数为一帧
    124                   && SerialPortRx.Buffer[SerialPortRx.Stack - UartRxDataLen]  ==0xff//校验字头
    125                     && SerialPortRx.Buffer[SerialPortRx.Stack - UartRxDataLen+1]==0x55
    126                       && SerialPortRx.Buffer[SerialPortRx.Stack - UartRxDataLen+2]==0xaa
    127                         && SerialPortRx.Buffer[SerialPortRx.Stack - UartRxDataLen+3]==0x10)
   \   00000042   0x....             LDR.N    R0,??DataTable4_10
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x2829             CMP      R0,#+41
   \   00000048   0xF2C0 0x808D      BLT.W    ??uart4_isr_2
   \   0000004C   0x....             LDR.N    R0,??DataTable4_10
   \   0000004E   0x....             LDR.N    R1,??DataTable4_10
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0x1808             ADDS     R0,R1,R0
   \   00000054   0xF810 0x0C23      LDRB     R0,[R0, #-35]
   \   00000058   0x28FF             CMP      R0,#+255
   \   0000005A   0xF040 0x8084      BNE.W    ??uart4_isr_2
   \   0000005E   0x....             LDR.N    R0,??DataTable4_10
   \   00000060   0x....             LDR.N    R1,??DataTable4_10
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x1808             ADDS     R0,R1,R0
   \   00000066   0xF810 0x0C22      LDRB     R0,[R0, #-34]
   \   0000006A   0x2855             CMP      R0,#+85
   \   0000006C   0xD17B             BNE.N    ??uart4_isr_2
   \   0000006E   0x....             LDR.N    R0,??DataTable4_10
   \   00000070   0x....             LDR.N    R1,??DataTable4_10
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0x1808             ADDS     R0,R1,R0
   \   00000076   0xF810 0x0C21      LDRB     R0,[R0, #-33]
   \   0000007A   0x28AA             CMP      R0,#+170
   \   0000007C   0xD173             BNE.N    ??uart4_isr_2
   \   0000007E   0x....             LDR.N    R0,??DataTable4_10
   \   00000080   0x....             LDR.N    R1,??DataTable4_10
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0x1808             ADDS     R0,R1,R0
   \   00000086   0xF810 0x0C20      LDRB     R0,[R0, #-32]
   \   0000008A   0x2810             CMP      R0,#+16
   \   0000008C   0xD16B             BNE.N    ??uart4_isr_2
    128                {//double data 9个通道数据校验
    129                  SerialPortRx.Check = 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x....             LDR.N    R1,??DataTable4_10
   \   00000092   0xF881 0x006B      STRB     R0,[R1, #+107]
    130                  b = SerialPortRx.Stack - UartRxDataLen;//起始位
   \   00000096   0x....             LDR.N    R0,??DataTable4_10
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0xF1B0 0x0429      SUBS     R4,R0,#+41
    131                  for(i=b;i<SerialPortRx.Stack-1;i++)//除校验位外的位进行校验
   \   0000009E   0x0025             MOVS     R5,R4
   \   000000A0   0xE00A             B.N      ??uart4_isr_3
    132                  {
    133                    SerialPortRx.Check += SerialPortRx.Buffer[i];//校验
   \                     ??uart4_isr_4: (+1)
   \   000000A2   0x....             LDR.N    R0,??DataTable4_10
   \   000000A4   0xF890 0x006B      LDRB     R0,[R0, #+107]
   \   000000A8   0x....             LDR.N    R1,??DataTable4_10
   \   000000AA   0x1869             ADDS     R1,R5,R1
   \   000000AC   0x7989             LDRB     R1,[R1, #+6]
   \   000000AE   0x1808             ADDS     R0,R1,R0
   \   000000B0   0x....             LDR.N    R1,??DataTable4_10
   \   000000B2   0xF881 0x006B      STRB     R0,[R1, #+107]
    134                  }
   \   000000B6   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uart4_isr_3: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable4_10
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x1E40             SUBS     R0,R0,#+1
   \   000000BE   0x4285             CMP      R5,R0
   \   000000C0   0xDBEF             BLT.N    ??uart4_isr_4
    135                  if(SerialPortRx.Check == SerialPortRx.Buffer[SerialPortRx.Stack-1])
   \   000000C2   0x....             LDR.N    R0,??DataTable4_10
   \   000000C4   0xF890 0x006B      LDRB     R0,[R0, #+107]
   \   000000C8   0x....             LDR.N    R1,??DataTable4_10
   \   000000CA   0x....             LDR.N    R2,??DataTable4_10
   \   000000CC   0x6812             LDR      R2,[R2, #+0]
   \   000000CE   0x1851             ADDS     R1,R2,R1
   \   000000D0   0x7949             LDRB     R1,[R1, #+5]
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD143             BNE.N    ??uart4_isr_5
    136                  {//校验成功，进行数据解算
    137                    for(i = 0;i<9;i++)
   \   000000D6   0x2500             MOVS     R5,#+0
   \   000000D8   0xE015             B.N      ??uart4_isr_6
    138                    {
    139                      d = SerialPortRx.Buffer[b+i*4+4]*0x1000000L + SerialPortRx.Buffer[b+i*4+5]*0x10000L + SerialPortRx.Buffer[b+i*4+6]*0x100L + SerialPortRx.Buffer[b+i*4+7];
    140                      if(d>0x7FFFFFFF)
    141                      {
    142                        d1 = 0x7FFFFFFF - d;
    143                      }
    144                      else
    145                      {
    146                        d1 = d;
    147                      }
    148                      UartData[i]=d1;
   \                     ??uart4_isr_7: (+1)
   \                     ??uart4_isr_8: (+1)
   \   000000DA   0x.... 0x....      BL       __aeabi_i2d
   \   000000DE   0x....             LDR.N    R2,??DataTable4_1
   \   000000E0   0xEB12 0x02C5      ADDS     R2,R2,R5, LSL #+3
   \   000000E4   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    149                      UartData[i]/=65536.0;
   \   000000E8   0x....             LDR.N    R0,??DataTable4_1
   \   000000EA   0xEB10 0x02C5      ADDS     R2,R0,R5, LSL #+3
   \   000000EE   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   000000F2   0x2200             MOVS     R2,#+0
   \   000000F4   0x....             LDR.N    R3,??DataTable4_11  ;; 0x40f00000
   \   000000F6   0x.... 0x....      BL       __aeabi_ddiv
   \   000000FA   0x....             LDR.N    R2,??DataTable4_1
   \   000000FC   0xEB12 0x02C5      ADDS     R2,R2,R5, LSL #+3
   \   00000100   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
   \   00000104   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uart4_isr_6: (+1)
   \   00000106   0x2D09             CMP      R5,#+9
   \   00000108   0xDA27             BGE.N    ??uart4_isr_9
   \   0000010A   0x....             LDR.N    R0,??DataTable4_10
   \   0000010C   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   00000110   0x1808             ADDS     R0,R1,R0
   \   00000112   0x7A80             LDRB     R0,[R0, #+10]
   \   00000114   0xF05F 0x7180      MOVS     R1,#+16777216
   \   00000118   0x....             LDR.N    R2,??DataTable4_10
   \   0000011A   0xEB14 0x0385      ADDS     R3,R4,R5, LSL #+2
   \   0000011E   0x189A             ADDS     R2,R3,R2
   \   00000120   0x7AD2             LDRB     R2,[R2, #+11]
   \   00000122   0xF45F 0x3380      MOVS     R3,#+65536
   \   00000126   0x435A             MULS     R2,R3,R2
   \   00000128   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000012C   0x....             LDR.N    R1,??DataTable4_10
   \   0000012E   0xEB14 0x0285      ADDS     R2,R4,R5, LSL #+2
   \   00000132   0x1851             ADDS     R1,R2,R1
   \   00000134   0x7B09             LDRB     R1,[R1, #+12]
   \   00000136   0xF44F 0x7280      MOV      R2,#+256
   \   0000013A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000013E   0x....             LDR.N    R1,??DataTable4_10
   \   00000140   0xEB14 0x0285      ADDS     R2,R4,R5, LSL #+2
   \   00000144   0x1851             ADDS     R1,R2,R1
   \   00000146   0x7B49             LDRB     R1,[R1, #+13]
   \   00000148   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   0000014C   0xF1B0 0x4F00      CMP      R0,#-2147483648
   \   00000150   0xD3C3             BCC.N    ??uart4_isr_7
   \   00000152   0xF07F 0x4100      MVNS     R1,#-2147483648
   \   00000156   0x1A08             SUBS     R0,R1,R0
   \   00000158   0xE7BF             B.N      ??uart4_isr_8
    150                    }
    151                    UartDebug();  //转去处理，把受到的数据付给变量
   \                     ??uart4_isr_9: (+1)
   \   0000015A   0x.... 0x....      BL       UartDebug
    152                  }
    153                  SerialPortRx.Stack = 0;
   \                     ??uart4_isr_5: (+1)
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0x....             LDR.N    R1,??DataTable4_10
   \   00000162   0x6008             STR      R0,[R1, #+0]
   \   00000164   0xE055             B.N      ??uart4_isr_0
    154                }
    155                else if(SerialPortRx.Stack >= UartRxCmdLen//UartRxDataLen个数为一帧
    156                        && SerialPortRx.Buffer[SerialPortRx.Stack - UartRxCmdLen]  ==0xff
    157                          && SerialPortRx.Buffer[SerialPortRx.Stack - UartRxCmdLen+1]==0x55
    158                            && SerialPortRx.Buffer[SerialPortRx.Stack - UartRxCmdLen+2]==0xaa
    159                              && SerialPortRx.Buffer[SerialPortRx.Stack - UartRxCmdLen+3]==0x77)//cmd
   \                     ??uart4_isr_2: (+1)
   \   00000166   0x....             LDR.N    R0,??DataTable4_10
   \   00000168   0x6800             LDR      R0,[R0, #+0]
   \   0000016A   0x2807             CMP      R0,#+7
   \   0000016C   0xDB51             BLT.N    ??uart4_isr_0
   \   0000016E   0x....             LDR.N    R0,??DataTable4_10
   \   00000170   0x....             LDR.N    R1,??DataTable4_10
   \   00000172   0x6809             LDR      R1,[R1, #+0]
   \   00000174   0x1808             ADDS     R0,R1,R0
   \   00000176   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \   0000017A   0x28FF             CMP      R0,#+255
   \   0000017C   0xD149             BNE.N    ??uart4_isr_0
   \   0000017E   0x....             LDR.N    R0,??DataTable4_10
   \   00000180   0x....             LDR.N    R1,??DataTable4_10
   \   00000182   0x6809             LDR      R1,[R1, #+0]
   \   00000184   0x5C08             LDRB     R0,[R1, R0]
   \   00000186   0x2855             CMP      R0,#+85
   \   00000188   0xD143             BNE.N    ??uart4_isr_0
   \   0000018A   0x....             LDR.N    R0,??DataTable4_10
   \   0000018C   0x....             LDR.N    R1,??DataTable4_10
   \   0000018E   0x6809             LDR      R1,[R1, #+0]
   \   00000190   0x1808             ADDS     R0,R1,R0
   \   00000192   0x7840             LDRB     R0,[R0, #+1]
   \   00000194   0x28AA             CMP      R0,#+170
   \   00000196   0xD13C             BNE.N    ??uart4_isr_0
   \   00000198   0x....             LDR.N    R0,??DataTable4_10
   \   0000019A   0x....             LDR.N    R1,??DataTable4_10
   \   0000019C   0x6809             LDR      R1,[R1, #+0]
   \   0000019E   0x1808             ADDS     R0,R1,R0
   \   000001A0   0x7880             LDRB     R0,[R0, #+2]
   \   000001A2   0x2877             CMP      R0,#+119
   \   000001A4   0xD135             BNE.N    ??uart4_isr_0
    160                {
    161                  SerialPortRx.Check = 0;
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x....             LDR.N    R1,??DataTable4_10
   \   000001AA   0xF881 0x006B      STRB     R0,[R1, #+107]
    162                  b = SerialPortRx.Stack - UartRxCmdLen;//起始位
   \   000001AE   0x....             LDR.N    R0,??DataTable4_10
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0x1FC4             SUBS     R4,R0,#+7
    163                  for(i=b; i<SerialPortRx.Stack-1; i++)//除校验位外的位进行校验
   \   000001B4   0x0025             MOVS     R5,R4
   \   000001B6   0xE00A             B.N      ??uart4_isr_10
    164                  {
    165                    SerialPortRx.Check += SerialPortRx.Buffer[i];//校验
   \                     ??uart4_isr_11: (+1)
   \   000001B8   0x....             LDR.N    R0,??DataTable4_10
   \   000001BA   0xF890 0x006B      LDRB     R0,[R0, #+107]
   \   000001BE   0x....             LDR.N    R1,??DataTable4_10
   \   000001C0   0x1869             ADDS     R1,R5,R1
   \   000001C2   0x7989             LDRB     R1,[R1, #+6]
   \   000001C4   0x1808             ADDS     R0,R1,R0
   \   000001C6   0x....             LDR.N    R1,??DataTable4_10
   \   000001C8   0xF881 0x006B      STRB     R0,[R1, #+107]
    166                  }
   \   000001CC   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uart4_isr_10: (+1)
   \   000001CE   0x....             LDR.N    R0,??DataTable4_10
   \   000001D0   0x6800             LDR      R0,[R0, #+0]
   \   000001D2   0x1E40             SUBS     R0,R0,#+1
   \   000001D4   0x4285             CMP      R5,R0
   \   000001D6   0xDBEF             BLT.N    ??uart4_isr_11
    167                  if(SerialPortRx.Check == SerialPortRx.Buffer[SerialPortRx.Stack-1])
   \   000001D8   0x....             LDR.N    R0,??DataTable4_10
   \   000001DA   0xF890 0x006B      LDRB     R0,[R0, #+107]
   \   000001DE   0x....             LDR.N    R1,??DataTable4_10
   \   000001E0   0x....             LDR.N    R2,??DataTable4_10
   \   000001E2   0x6812             LDR      R2,[R2, #+0]
   \   000001E4   0x1851             ADDS     R1,R2,R1
   \   000001E6   0x7949             LDRB     R1,[R1, #+5]
   \   000001E8   0x4288             CMP      R0,R1
   \   000001EA   0xD10B             BNE.N    ??uart4_isr_12
    168                  {//校验成功
    169                    UartCmd(UartCmdNum,UartCmdData);//处理接收到的命令，付给MCU命令变量
   \   000001EC   0x....             LDR.N    R0,??DataTable4_10
   \   000001EE   0x....             LDR.N    R1,??DataTable4_10
   \   000001F0   0x6809             LDR      R1,[R1, #+0]
   \   000001F2   0x1808             ADDS     R0,R1,R0
   \   000001F4   0x7901             LDRB     R1,[R0, #+4]
   \   000001F6   0x....             LDR.N    R0,??DataTable4_10
   \   000001F8   0x....             LDR.N    R2,??DataTable4_10
   \   000001FA   0x6812             LDR      R2,[R2, #+0]
   \   000001FC   0x1810             ADDS     R0,R2,R0
   \   000001FE   0x78C0             LDRB     R0,[R0, #+3]
   \   00000200   0x.... 0x....      BL       UartCmd
    170                  }
    171                  SerialPortRx.Stack = 0;
   \                     ??uart4_isr_12: (+1)
   \   00000204   0x2000             MOVS     R0,#+0
   \   00000206   0x....             LDR.N    R1,??DataTable4_10
   \   00000208   0x6008             STR      R0,[R1, #+0]
   \   0000020A   0xE002             B.N      ??uart4_isr_0
    172                }
    173              }
    174              else
    175              {
    176                SerialPortRx.Stack = 0;
   \                     ??uart4_isr_1: (+1)
   \   0000020C   0x2000             MOVS     R0,#+0
   \   0000020E   0x....             LDR.N    R1,??DataTable4_10
   \   00000210   0x6008             STR      R0,[R1, #+0]
    177              } 
    178            }
    179          }
   \                     ??uart4_isr_0: (+1)
   \   00000212   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     UartData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     Speed_PID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     car_stop_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     Turn_PID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     stopflag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     uSendBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     FreeCarsDataNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x400EA004         DC32     0x400ea004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x400EA003         DC32     0x400ea003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     SerialPortRx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x40F00000         DC32     0x40f00000
    180          
    181          
    182          
    183          
    184          
    185          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UartCmd
         8   -> LPLD_UART_PutChar
       8   UartDebug
         8   -> LPLD_UART_PutChar
         8   -> __aeabi_d2f
         8   -> __aeabi_d2iz
         8   -> __aeabi_i2f
         8 __aeabi_cdcmpeq
       0   push
      16   sendDataToScope
        16   -> LPLD_UART_PutChar
      16   uart4_isr
        16   -> LPLD_UART_GetChar
        16   -> UartCmd
        16   -> UartDebug
        16   -> __aeabi_ddiv
        16   -> __aeabi_i2d


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       1  FreeCarsDataNum
     108  SerialPortRx
      58  UartCmd
      72  UartData
     232  UartDebug
      44  push
      88  sendDataToScope
       1  stopflag
      36  uSendBuf
     532  uart4_isr

 
   217 bytes in section .bss
     1 byte  in section .data
 1 002 bytes in section .text
 
 1 002 bytes of CODE memory
   218 bytes of DATA memory

Errors: none
Warnings: 4
